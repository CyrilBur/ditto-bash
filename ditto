#!/bin/bash
set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
LIGHT_GREY='\033[0;37m'
NORMAL='\033[0m'

#---------------------------------------------------------------------------------------------------

function EchoMessage() {
    local message=$1
    local colour=${2:-${NORMAL}}
    echo -e "${colour}${message}${NORMAL}" >&1
    return 0
}

#---------------------------------------------------------------------------------------------------

function EchoWarning() {
    local message=$1
    echo -e "${YELLOW}${message}${NORMAL}" >&2
    return 0
}

#---------------------------------------------------------------------------------------------------

function EchoError() {
    local message=$1
    echo -e "${RED}${message}${NORMAL}" >&2
    return 0
}

#---------------------------------------------------------------------------------------------------

function GetRegexMatches() {
    local __regex_result=$1
    local string=$2
    local regex=$3
    
    if [[ $string =~ $regex ]]; then
        eval "$__regex_result="'("${BASH_REMATCH[@]:1}")'
        return 0
    fi

    return 1
}

#---------------------------------------------------------------------------------------------------

function GetRegexMatch() {
    local string=$1
    local regex=$2
    local errorMessage=$3

    if ! GetRegexMatches matches "$string" "$regex"; then
        EchoError "${errorMessage}"
        exit 1
    fi

    local numMatches=${#matches[@]}

    if [ "$numMatches" -ne "1" ]; then
       EchoError "${errorMessage}"
       exit 1
    fi

    echo ${matches[0]}
    return 0
}

#---------------------------------------------------------------------------------------------------

function GetOid() {
    local oid=$(git rev-parse HEAD)

    if [ "$?" -ne "0" ]; then
        EchoError "Failed to get SHA"
        exit 1
    fi

    echo "$oid"
}

#---------------------------------------------------------------------------------------------------

function GetUniqueFileName() {
    local nameBase=$1
    local extension=$2
    local n=1;

    if [ ! -f "$nameBase$extension" ]; then
        echo "$nameBase$extension"
        return 0
    fi

    while [ -f "${nameBase}_$n$extension" ]; do 
        ((++n))
    done
    
    echo "${nameBase}_$n$extension"
    return 0
}

#---------------------------------------------------------------------------------------------------

if [[ -z "$DITTO_TOKEN" ]]; then
    EchoError "Environment variable DITTO_TOKEN was not set"
    exit 1
fi

oid=$(GetOid)
branchInfo=$(GetRegexMatch "$(git branch -vv)" ".*\[(.*)\].*" "Failed to find branch information") || exit
branchInfoArray=(${branchInfo//\// })
remoteName=${branchInfoArray[0]}

regex="$remoteName[[:space:]](.*)[[:space:]]\(fetch\)"
remoteName=$(GetRegexMatch "$(git remote -v)" "$remoteName[[:space:]](.*)[[:space:]]\(fetch\)" "Failed to find remote with name $remoteName") || exit

if ! GetRegexMatches slug "$remoteName" ".*[/:](.*[/:].*).git"; then
    EchoError "Failed to analyze git slug for remote $remoteName"
    exit 1
fi

slugArray=(${slug//\// })
userName=${slugArray[0]}
repoName=${slugArray[1]}

EchoMessage "Found user name: ${LIGHT_GREY}$userName"
EchoMessage "Found repo name: ${LIGHT_GREY}$repoName"
EchoMessage "Found SHA: ${LIGHT_GREY}$oid"

reportFound=false
multipleReportsFound=false

for f in $(ls -1t heaptrack.*.{zst,gz} 2> /dev/null); do
    if [ "$reportFound" = true ]; then
        multipleReportsFound=true
    else
        fileLocation=$f
    fi
    reportFound=true
done

if [ "$reportFound" = false ]; then
    EchoError "No report matching heaptrack.*.{zst,gz} was found"
    exit 1
fi

if [ "$multipleReportsFound" = true ]; then
    EchoWarning "Multiple heaptrack reports found; uploading most recent one"
fi

# We require gzip formatting, not zstd
if [ "${fileLocation: -3:3}" = "zst" ]; then
    EchoMessage "Recompressing using gzip"
    command -v zstd >/dev/null 2>&1 || { EchoError "File was in zstd format but zstd was not found"; exit; }
    tmpFileLocation=$(GetUniqueFileName ditto ".$RANDOM")
    zstd -d -o $tmpFileLocation $fileLocation >/dev/null 2>&1 || { EchoError "Failed to decompress zstd file"; exit; }
    fileLocation="$tmpFileLocation.gz"
    gzip -nf9 $tmpFileLocation > $fileLocation || { EchoError "Failed to compress gzip file"; exit; }
fi

EchoMessage "Uploading to Ditto"
#getUploadLinkUrl='https://ditt.io/upload'
getUploadLinkUrl='https://us-central1-ditto-profiling.cloudfunctions.net/uploadRequest'

command -v curl >/dev/null 2>&1 || { EchoError "curl required to upload reports but it was not found"; exit; }
res=$(curl --silent --write-out "|%{http_code}" --form user=$userName --form repo=$repoName --form oid=$oid --form token=$DITTO_TOKEN $getUploadLinkUrl)

if [ "$?" -ne "0" ]; then
    EchoError "An unknown error occurred"
    exit 1;
fi

IFS='|' read -ra resArray <<< "$res"
message=${resArray[0]}
statusCode=${resArray[1]}

if [ "${statusCode:-400}" -ne "200" ]; then
    EchoError "Upload failed: $message"
    exit 1
fi

uploadUrl=$message

if [[ -z $uploadUrl ]]; then
    EchoError "Upload failed: no url given"
    exit 1
fi

res=$(cat $fileLocation | curl --write-out "|%{http_code}" -H 'Content-Type: text/plain' -H 'Content-Encoding: gzip' --upload-file $fileLocation $uploadUrl)
rm $fileLocation

if [ "$?" -ne "0" ]; then
    EchoError "An unknown error occurred"
    exit 1;
fi

IFS='|' read -ra resArray <<< "$res"
message=${resArray[0]}
statusCode=${resArray[1]}

if [ "${statusCode:-400}" -ne "200" ]; then
    EchoError "Upload failed: $message"
    exit 1
fi

EchoMessage "Upload succeeded" "$GREEN"
exit 0